"""
FastAPI Backend for IGotYou Agent

This file provides a REST API interface to the IGotYou Python agent.
It handles CORS, request validation, and response formatting.

ENDPOINTS:
    GET  /          ‚Üí Health check endpoint
    POST /api/discover ‚Üí Discover hidden outdoor gems
    GET  /health/mcp   ‚Üí Check MCP weather server status (NEW!)

USAGE:
    python backend/main.py
    # Server runs at http://localhost:8000
    # API docs at http://localhost:8000/docs
"""

import sys
import os
from pathlib import Path

# Add parent directory to path to import agent package
# This allows us to import the agent module from the parent directory
sys.path.append(str(Path(__file__).parent.parent))

# FastAPI imports for building the REST API
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware

# Pydantic for request/response validation
from pydantic import BaseModel, Field
from typing import List, Optional

# Standard library imports
import asyncio
import re

# Import the agent from our agent module (using agent/ directory structure)
from agent import root_agent, runner


# ============================================================================
# FASTAPI APP CONFIGURATION
# ============================================================================

app = FastAPI(
    title="I Got You API",
    description="API for discovering hidden outdoor gems with AI-powered recommendations",
    version="1.0.0"
)


# ============================================================================
# CORS CONFIGURATION
# ============================================================================

# Get allowed origins from environment variable (comma-separated list)
# Default to localhost:3000 for local development
allowed_origins = os.getenv("CORS_ORIGINS", "http://localhost:3000").split(",")

# Add CORS middleware to allow frontend to make requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,  # Origins that can make requests
    allow_credentials=True,          # Allow cookies/auth headers
    allow_methods=["*"],             # Allow all HTTP methods
    allow_headers=["*"],             # Allow all headers
)


# ============================================================================
# PYDANTIC MODELS (Request/Response Schemas)
# ============================================================================

class DiscoveryRequest(BaseModel):
    """
    Request model for the /api/discover endpoint.
    
    Attributes:
        searchQuery: The user's search query (10-200 characters)
                    Example: "quiet beaches in California"
    """
    searchQuery: str = Field(..., min_length=10, max_length=200)


class Coordinates(BaseModel):
    """
    Geographic coordinates for a location.
    
    Attributes:
        lat: Latitude (-90 to 90)
        lng: Longitude (-180 to 180)
    """
    lat: float
    lng: float


# ============================================================================
# NEW: WEATHER MODEL (MCP Integration)
# ============================================================================

class Weather(BaseModel):
    """
    Weather data for a location from MCP weather server.
    
    This data is fetched from AccuWeather via the MCP protocol
    and provides current conditions for each hidden gem.
    
    Attributes:
        temperature: Current temperature in Fahrenheit (nullable if unavailable)
        conditions: Weather description (e.g., "Partly Cloudy", "Rainy")
        humidity: Humidity percentage 0-100 (nullable if unavailable)
        hasPrecipitation: Whether it's currently raining/snowing
    """
    temperature: Optional[float] = None
    conditions: Optional[str] = None
    humidity: Optional[int] = None
    hasPrecipitation: bool = False


# ============================================================================
# ANALYSIS MODEL (Updated with clothingRecommendation)
# ============================================================================

class Analysis(BaseModel):
    """
    AI-generated analysis and insights for a hidden gem.
    
    This is generated by the Recommendation Agent based on user reviews.
    
    Attributes:
        whySpecial: 2-3 sentences explaining why this is a hidden gem
        bestTime: When to visit for the best experience
        insiderTip: Practical tip based on reviews
        clothingRecommendation: What to wear based on weather (NEW!)
    """
    whySpecial: str
    bestTime: str
    insiderTip: str
    # NEW: AI-generated clothing recommendation based on weather
    clothingRecommendation: Optional[str] = None


# ============================================================================
# HIDDEN GEM MODEL (Updated with weather field)
# ============================================================================

class HiddenGem(BaseModel):
    """
    A discovered hidden gem with all its details.
    
    This is the main data model returned by the agent pipeline.
    
    Attributes:
        placeName: Name of the place
        address: Full address
        coordinates: Geographic location for mapping
        rating: Google rating (0-5 stars)
        reviewCount: Number of reviews
        photos: Array of photo URLs
        analysis: AI-generated insights
        weather: Current weather conditions (NEW!)
    """
    placeName: str
    address: str
    coordinates: Coordinates
    rating: float
    reviewCount: int
    photos: List[str]
    analysis: Analysis
    # NEW: Weather data from MCP weather server
    weather: Optional[Weather] = None


class DiscoveryResponse(BaseModel):
    """
    Response model for the /api/discover endpoint.
    
    Attributes:
        gems: List of discovered hidden gems
        processingTime: How long the request took (in seconds)
        query: The original search query
    """
    gems: List[HiddenGem]
    processingTime: float
    query: str


# ============================================================================
# RESPONSE PARSING HELPERS
# ============================================================================

def _find_gems_json(text: str) -> str | None:
    """
    Find JSON object containing "gems" key using brace-counting algorithm.
    
    This is more robust than greedy regex (r'{.*"gems".*}') because:
    - Greedy regex matches from ANY '{' to ANY '}' in the response
    - If the agent response has stray braces like "text { } {"gems": [...]} more"
      the regex would capture everything from the first { to last }
    - Brace-counting finds the correctly balanced JSON object
    
    Args:
        text: Raw response text that may contain JSON
    
    Returns:
        str: The extracted JSON string, or None if not found
    
    Example:
        Input:  'Here is the result: {"gems": [{"name": "Beach"}]} Great!'
        Output: '{"gems": [{"name": "Beach"}]}'
    """
    # First, find the "gems" key in the text
    gems_idx = text.find('"gems"')
    if gems_idx == -1:
        return None
    
    # Find the opening brace '{' that precedes "gems"
    # This is the start of our JSON object
    start_idx = text.rfind('{', 0, gems_idx)
    if start_idx == -1:
        return None
    
    # Count braces to find the matching closing brace
    # This handles nested objects like {"gems": [{"coordinates": {"lat": 1}}]}
    brace_count = 0
    for i in range(start_idx, len(text)):
        if text[i] == '{':
            brace_count += 1  # Opening brace: increment count
        elif text[i] == '}':
            brace_count -= 1  # Closing brace: decrement count
            if brace_count == 0:
                # Found matching closing brace - extract the JSON substring
                return text[start_idx:i + 1]
    
    # Unbalanced braces - couldn't find matching close
    return None


def parse_agent_response(raw_response: str, query: str) -> dict:
    """
    Parse the agent's JSON response into structured data.
    
    The agent returns JSON, but it might be wrapped in markdown code blocks.
    This function extracts and parses the JSON, with fallback for errors.
    
    Args:
        raw_response: Raw string response from the agent
        query: Original search query (for error messages)
    
    Returns:
        dict: Parsed response with "gems" array
    """
    import json
    
    try:
        # Convert response to string if needed
        response_text = str(raw_response)

        # Try to find JSON in the response (handles markdown code blocks)
        # Pattern 1: ```json ... ``` or ``` ... ```
        # 
        # IMPORTANT: We use GREEDY matching (\{.*\}) instead of non-greedy (\{.*?\})
        # because JSON often contains nested objects like:
        #   {"gems": [{"coordinates": {"lat": 1, "lng": 2}}]}
        # 
        # Non-greedy would stop at the FIRST "}" it finds, breaking nested structures.
        # Greedy matching captures from the first "{" to the LAST "}" in the code block,
        # which is what we want for complete JSON extraction.
        json_match = re.search(r'```(?:json)?\s*(\{.*\})\s*```', response_text, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            # Pattern 2: Find JSON object with "gems" key using brace-counting
            # This is more robust than greedy regex which can match stray braces
            json_str = _find_gems_json(response_text)
            if not json_str:
                # Assume the whole response is JSON
                json_str = response_text

        # Parse the JSON string
        parsed_data = json.loads(json_str)
        
        if "gems" in parsed_data and isinstance(parsed_data["gems"], list):
            return parsed_data
        else:
            raise ValueError("Invalid response format: missing 'gems' array")
        
    except Exception as e:
        # Log the error for debugging
        print(f"Error parsing agent response: {e}")
        print(f"Raw response: {raw_response[:500]}...")

        # Return fallback error data so the frontend doesn't break
        return {
            "gems": [
                {
                    "placeName": "Unable to parse results",
                    "address": "Please try a different search query",
                    "coordinates": {"lat": 0, "lng": 0},
                    "rating": 0,
                    "reviewCount": 0,
                    "photos": ["https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=800"],
                    "analysis": {
                        "whySpecial": f"Error: {str(e)}",
                        "bestTime": "N/A",
                        "insiderTip": "Try rephrasing your search query",
                        "clothingRecommendation": None  # NEW field
                    },
                    "weather": None  # NEW field
                }
            ]}
        }


# ============================================================================
# API ENDPOINTS
# ============================================================================

@app.get("/")
async def root():
    """
    Health check endpoint.
    
    Returns basic service information to verify the API is running.
    
    Returns:
        dict: Service status, name, and version
    """
    return {
        "status": "healthy",
        "service": "I Got You API",
        "version": "1.0.0"
    }


# ============================================================================
# NEW: MCP HEALTH CHECK ENDPOINT
# ============================================================================

@app.get("/health/mcp")
async def mcp_health_check():
    """
    Check if MCP weather server is accessible.
    
    This endpoint verifies that the weather functionality is working.
    Useful for debugging and monitoring.
    
    Returns:
        dict: Status of MCP weather service
            - "healthy": Weather service is available
            - "degraded": Weather service is unavailable (app still works)
    """
    try:
        # Check if AccuWeather API key is configured
        accuweather_key = os.getenv("ACCUWEATHER_API_KEY")
        
        if not accuweather_key:
            return {
                "status": "degraded",
                "mcp_weather": "not_configured",
                "message": "ACCUWEATHER_API_KEY not set in environment"
            }
        
        # Try to import MCP library
        try:
            import mcp
            mcp_installed = True
        except ImportError:
            mcp_installed = False
        
        if not mcp_installed:
            return {
                "status": "degraded",
                "mcp_weather": "mcp_not_installed",
                "message": "MCP library not installed. Run: pip install mcp"
            }
        
        # All checks passed
        return {
            "status": "healthy",
            "mcp_weather": "available",
            "message": "MCP weather integration is configured"
        }
        
    except Exception as e:
        return {
            "status": "degraded",
            "mcp_weather": "error",
            "message": str(e)
        }


@app.post("/api/discover")
async def discover_gems(request: DiscoveryRequest):
    """
    Discover hidden outdoor gems based on search query.
    
    This is the main endpoint that runs the full agent pipeline:
    Discovery ‚Üí Analysis ‚Üí Recommendation ‚Üí Weather
    
    Args:
        request: DiscoveryRequest with searchQuery field
    
    Returns:
        DiscoveryResponse with:
            - gems: Array of hidden gem recommendations
            - processingTime: How long the request took
            - query: Original search query
    
    Example:
        POST /api/discover
        {"searchQuery": "quiet beaches in California"}
        
        Response:
        {
            "gems": [...],
            "processingTime": 12.5,
            "query": "quiet beaches in California"
        }
    """
    # Log the incoming request
    print(f"\n{'='*60}")
    print(f"Received search query: {request.searchQuery}")
    print(f"{'='*60}")
    
    try:
        import time
        start_time = time.time()

        print(f"[Backend] Running agent with query: {request.searchQuery}")

        # Run the full agent pipeline
        # This goes through: Discovery ‚Üí Analysis ‚Üí Recommendation ‚Üí Weather
        response = await runner.run_debug(request.searchQuery)

        # Log response info
        print(f"[Backend] Agent response received (length: {len(str(response))})")
        print(f"[Backend] Agent response preview: {str(response)[:200]}...")

        # Parse response into structured format
        parsed_data = parse_agent_response(str(response), request.searchQuery)
        processing_time = time.time() - start_time

        print(f"[Backend] Successfully parsed {len(parsed_data['gems'])} gems")
        print(f"[Backend] Processing time: {processing_time:.2f}s")

        # Return the final response
        return {
            "gems": parsed_data["gems"],
            "processingTime": processing_time,
            "query": request.searchQuery
        }
        
    except Exception as e:
        # Log the full error for debugging
        print(f"[Backend] ERROR in discover_gems endpoint: {e}")
        import traceback
        traceback.print_exc()
        
        # Return HTTP 500 error
        raise HTTPException(
            status_code=500,
            detail=f"Error processing request: {str(e)}"
        )


# ============================================================================
# LIFECYCLE EVENTS
# ============================================================================

@app.on_event("shutdown")
async def shutdown_event():
    """
    Clean up resources when the server shuts down.
    
    This ensures the agent runner is properly closed to free resources.
    """
    try:
        await runner.close()
    except:
        pass  # Ignore errors during cleanup


# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    
    # Print startup banner
    print("\n" + "="*60)
    print("üöÄ Starting I Got You Backend API Server")
    print("="*60)
    print("üìç Server will run at: http://localhost:8000")
    print("üìö API Docs available at: http://localhost:8000/docs")
    print("üå§Ô∏è MCP Weather: Check /health/mcp for status")
    print("üîÑ Waiting for requests...")
    print("="*60 + "\n")
    
    # Start the uvicorn server
    uvicorn.run(app, host="0.0.0.0", port=8000)
